{
    "segments": [
        {
            "topic": "Introduction to Binary Trees",
            "text": "Alright class, let\u2019s get started with today\u2019s topic, which is Binary Search Trees. But before we jump into that, let's first make sure we understand what a Binary Tree is. We talked about what is a tree last time, a binary tree is just a tree structure where each node has at most two children. These children are commonly referred to as the left and right children.\nNow, let me draw an example. Is this a Binary Tree? Who thinks this is a binary tree? Who thinks it's not? Alright so the majority think this is a binary tree. And indeed you are right. As you can see here, we have a tree where every node has either zero, one, or two children. This is a binary tree. What about this one? This is not a binary tree. This node here, the root node has three children. But a binary tree is strictly limited to two children per node."
        },
        {
            "topic": "Definition of Binary Search Trees",
            "text": "Moving on from that, let\u2019s define what a Binary Search Tree is, and more importantly, what makes it different from a regular binary tree. The main distinction is that in a binary search tree, the left child of a node contains values that are less than the parent, and the right child contains values that are greater than the parent. This ordering rule allows binary search trees to be very efficient for operations like search, insertion, and deletion.\nLet me draw a binary search tree now. So, for example here, if you have a node with the value 10, all the nodes in its left subtree will have values smaller than 10, and all the nodes in its right subtree will have values larger than 10. This property helps maintain a sorted order within the tree, which is key for its efficiency. We will see why soon.\nWhy do we use binary search trees? Binary search trees are very useful for cases where we need to store data that changes dynamically and still maintain quick lookup times. They allow you to efficiently insert new elements, delete existing ones, and search for values\u2014all while keeping the dataset sorted. If you were using something like an array, inserting or deleting values could involve shifting elements around, which can be slow. In contrast, binary search trees make these operations much faster."
        },
        {
            "topic": "Insertion Operation",
            "text": "Moving on to the operations, the first operation we\u2019ll talk about is inserting a new value into the tree. The way you insert a value is by starting at the root and comparing the value to the current node. If the value is smaller, you go left; if it\u2019s larger, you go right. You keep doing this until you find an empty spot, and that\u2019s where the new value goes.\nFor example, if we want to insert the value 9 into a binary search tree, we start at the root. If 9 is smaller than the root value, we go left; if it\u2019s larger, we go right. We repeat this process until we find an empty spot. Once we find that empty spot, we insert 9 as a new node. Pretty straightforward."
        },
        {
            "topic": "Deletion Operation",
            "text": "Now, for deleting a value, it\u2019s a little more complicated. Step one, you find the node to delete. Step two. If the node you want to delete has no children, it's easy\u2014you just remove it. But if the node has one child, you need to reconnect that child to the parent of the node you\u2019re deleting. If the node has two children, things get more interesting. You replace the node with its in-order successor or predecessor, which is the smallest value in the right subtree or the largest value in the left subtree. After that, you reconnect the tree, making sure to maintain the binary search property.\nLet\u2019s say we want to delete a node with the value 10. If 10 has no children, we can just remove it. If 10 has one child, we replace 10 with that child. If 10 has two children, we find the in-order successor, which is the smallest value in the right subtree, and replace 10 with that value. After that, we make sure everything else in the tree is still correctly connected."
        },
        {
            "topic": "Time Complexity and Big-O Notation",
            "text": "Now, let\u2019s discuss the time complexity of these operations. For both insertion and deletion, the time it takes is proportional to the height of the tree. Who can tell me what is the relationship between height of tree and the number of node in the tree? Yes, Ryan. You all almost correct. In the best case, when the tree is balanced, the height of the tree is logarithmic with respect to the number of nodes. That means both insert and delete operations take \"Big-O of log N\" time.\nHowever, if the tree becomes unbalanced\u2014like if you keep adding values in increasing order\u2014the tree can degrade into a structure more like a linked list, where every node only has one child. In that case, the height of the tree is equal to the number of nodes, and the time complexity degrades to \"Big-O of N.\" That\u2019s why balancing the tree is so important, but we\u2019ll cover balancing techniques like AVL trees and Red-Black trees in a future lecture.\nLet\u2019s talk a little more about Big-O Notation. Big-O notation is a way of describing the upper bound of an algorithm\u2019s time complexity. It gives you an idea of the worst-case scenario for how long an operation will take as the input size grows.\nIntuitively, when we say \"Big-O of log N,\" it means that as the number of nodes in the tree grows, the time it takes to perform an operation increases logarithmically. So, if you double the number of nodes, the time doesn\u2019t double\u2014it increases by a much smaller amount, following a logarithmic pattern.\nRigorously, we define Big-O notation using limits. We say that a function f of N is Big-O of g N if there exists a constant C and a value N nod such that for all N greater than N nod, the inequality absolute value of f N less than or equal to C times g N holds. In the case of a balanced binary search tree, we would say that the time complexity for insert or delete is \"Big-O of log N,\" because the number of operations needed is proportional to the height of the tree, which is logarithmic in the number of nodes."
        },
        {
            "topic": "Conclusion",
            "text": "Alright, that\u2019s the overview for today. We\u2019ve covered binary trees, binary search trees, how to insert and delete nodes, and how time complexity works. Make sure to practice these operations on different trees, and we\u2019ll dig deeper into balancing techniques in future lectures. Homework is posted on Canvas and will be due next Friday. Get started on it now and go to TA\u2019s office hours if you encounter any problems. See you next time!"
        }
    ]
}