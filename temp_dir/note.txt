# Binary Search Tree

## Summary
This lecture covers the fundamental concepts of binary search trees (BSTs), including their structure, operations (insertion and deletion), and time complexity analysis using Big-O notation. The lecture also differentiates between binary trees and binary search trees, emphasizing the importance of maintaining a balanced tree for efficient operations.

## Outline
1. Introduction to Binary Trees
   1. Definition
   2. Example of a Binary Tree
2. Binary Search Trees (BST)
   1. Definition and Properties
   2. Example of a BST
3. Operations on BST
   1. Insert Operation
   2. Delete Operation
4. Time Complexity and Big-O Notation
   1. Definition of Big-O Notation
   2. Time Complexity of BST Operations

## Detailed Notes

### 1. Introduction to Binary Trees
#### 1.1 Definition
- A binary tree is a data structure where each node has 0, 1, or 2 children.
- These children are commonly referred to as the left and right children.

#### 1.2 Example of a Binary Tree
- **Valid Binary Tree**: Each node has at most two children.
- **Invalid Binary Tree**: A node with more than two children is not a binary tree.

![Binary Tree](https://en.wikipedia.org/wiki/Binary_tree)

### 2. Binary Search Trees (BST)
#### 2.1 Definition and Properties
- A binary search tree is a binary tree with an additional property: for any given node, all values in the left subtree are less than the node's value, and all values in the right subtree are greater.
- This property allows for efficient search, insertion, and deletion operations.

#### 2.2 Example of a BST
- Example: A BST with nodes labeled as 10, 4, 13, 15, 1, 7, 6, and 9.
- Comparisons: 9 is greater than 4 and less than 10; 7 is less than 9.

![Binary Search Tree](https://en.wikipedia.org/wiki/Binary_search_tree)

### 3. Operations on BST
#### 3.1 Insert Operation
- To insert a value in a BST:
  1. Compare the value with the root.
  2. If the value is less than the root, move to the left child; if greater, move to the right child.
  3. Repeat the process until you find a suitable position.
- Example: Inserting 9 into the tree:
  - 9 is less than 10, so move left.
  - 9 is greater than 4, so move right.
  - 9 is inserted as the right child of 4.

#### 3.2 Delete Operation
- To delete a node from a BST:
  1. **Step 1**: Start from the root and find the node to delete.
  2. **Step 2**: Handle different cases for node deletion:
     - If the node has no children, simply remove it.
     - If the node has one child, reconnect the child to the parent of the node.
     - If the node has two children, find the in-order successor (smallest node in the right subtree) and replace the node's value with it, then delete the in-order successor.

### 4. Time Complexity and Big-O Notation
#### 4.1 Definition of Big-O Notation
- Big-O notation describes the upper bound of the time complexity of an algorithm.
- It provides an idea of the worst-case scenario for how long an operation will take as the input size grows.

#### 4.2 Time Complexity of BST Operations
- For both insertion and deletion, the time complexity is proportional to the height of the tree.
- **Best Case**: When the tree is balanced, the height is logarithmic with respect to the number of nodes, making the time complexity \( O(\log n) \).
- **Worst Case**: If the tree is unbalanced (e.g., a linked list structure), the height is equal to the number of nodes, making the time complexity \( O(n) \).

![Big-O Notation](https://en.wikipedia.org/wiki/Big_O_notation)

## Diagrams & Related Resources
- [Binary Tree Diagram](https://en.wikipedia.org/wiki/Binary_tree): Binary tree with at most two children per node; Incorrect structure with more than two children on the right.
- [Binary Search Tree Diagram](https://en.wikipedia.org/wiki/Binary_search_tree): Binary search tree with comparisons between nodes.
- [Big-O Notation Diagram](https://en.wikipedia.org/wiki/Big_O_notation): Definition and formal mathematical expression of Big-O notation.